# Задание 2 — сверстать макет

В этом репозитории находятся решение тестового задания по вёрстке для [14-й Школы разработки интерфейсов](https://academy.yandex.ru/events/frontend/shri_msk-2018-2) (осень 2018, Москва, Санкт-Петербург, Симферополь).

#### Запуск

1) `npm install` - cкачать и установить необходимые пакеты 
2) `npm start` - запустить сборку приложения и hot-reload сервер по адресу `localhost:9000`

Для тестирования приложения с мобильного устройства можно подключиться к этому серверу по его айпи в локальной 
или внешней сети.

#### Комментарии

В своём решении я попытался использовать БЭМ для наименования стилей и не использовал препроцессоры CSS.
Автоматизация была добавлена в проект в последнюю очередь, поэтому в исходных файлах стилей вы можете найти вручную 
проставленные префиксы, где это было необходимо сделать. От себя хочу добавить, что выполнения задания без использования
автоматизации дало мне очень полезный опыт и лучшее понимание потенциальных проблем.

Сборка проекта осуществляется с использованием Webpack. Также сконфигурирован hot-reload сервер, упрощающий разработку.
Собранные артефакты кладуться в папку dist в корне проекта.

Процесс сборки состоит из следующих этапов 
 - предварительная очистка директории dist
 - сборка javascript файлов в файл **main.[hash].js**
 - обработка и сборка стилей в файл **style.[hash].css**
 - добавление ссылок на файлы скрипта и стилей в файл разметки **index.html**
 - копирование полученных файлов в директорию **dist** 
 - копирование статических ресурсов в директорию **dist**
 
Автоматическое добавление хэшсумм к названию файлов сделано для того, чтобы решить проблемы, которые вызваны использованием 
браузером кэша.

Для обработки стилей используются
- PostCss - как средство для трансформации стилей со следующими плагинами:
  - autoprefixer - автоматическое добавление префиксов вендоров
  - postcss-clean - минификация CSS стилей
  
Для генерации плиток написан наивный javascript код, расположенный в templateMethods.js. 
Разметка, указанная в переменных с шаблонами, добавляется к странице после её загрузки.
Данные, на основе которых генерируюется плитка, расположены в файле data.js

Для анимации прокрутки и перелистывания по нажатию кнопок в решении используется [JQuery](https://github.com/jquery/jquery).
Обратите внимание, что когда секция "Избранные сценарии" находится справа от главной секции, в ней по нажатию 
кнопок-стрелок происходит не скролл, а "перелистывание", как указано в задании. Когда "Избранные сценарии" перемещаются 
под "Главное", по нажатию кнопок происходит скролл. Поскольку на трансляции, посвященной ответам на вопросы, говорилось,
что целевыми для приложения являются устройства с сенсорным вводом, я не стал скрывать стандартные полосы скролла, 
имеющие неказистый вид на PC.

Элемент управления под названием "круговой вращатель" был написан с использованием плагина 
[JQuery Knob](https://github.com/aterrien/jQuery-Knob). В плагине используется отображение графики на базе HTML5 Canvas,
что позволяет с помощью переопределения метода draw задать элементу необходимое поведение. К сожалению мне не пришло в 
голову хорошего варианта, как можно было бы сверстать внешние риски используя CSS и затем реализовать интерактивное 
закрашивание внешних рисок в зависимости от положения курсора. Я также рассматривал решение на основе SVG, но оно 
показалось мне менее привлекательным.

Код, который отвечает за динамическое появление двойных стрелок на частично видимых тайлах в секции "Главное" ведёт себя
не совсем корректно при изменении размеров окна - иногда стрелки остаются у полностью видимых тайлов. Чтобы убедиться 
в верной вёрстке предлагаю поскроллить область, в которой после ресайза остался элемент с двойными стрелками.

Анимацию появления открытия диалогового окна я бы делал следующим образом:
1) получить координаты тайла, на который нажал пользователь, относительно вьюпорта
2) создать div элемент с абсолютным позиционированием в переднем плане
3) одновременно начать анимацию затемнения и размытия фона, и анимацию перемещения в центр экрана и изменения размеров 
до размеров диалогового окна у созданного div-элемента
4) немного спустя запустить анимацию появления диалогового окна, которое имеет больший z-index, чем созданный 
div-элемент
5) удалить созданный для анимации div-элемент, когда завершится анимацию появления диалогового окна.

Для реализации сказанного я попытался использовать библиотеку [cta.js](https://github.com/chinchang/cta.js), 
но полученный результат не соответствовал представленному на [сайте](https://kushagragour.in/lab/ctajs/), 
и не удовлетворил меня. Поэтому моя анимация появления диалогового окна не имеет описанного в алгоритме 
динамического div-элемента. (Насколько я понял, вариант "описать как бы реализовал с использованием JS" 
засчитывается)

Открытие дилоговых окон управления доступно только в секции "Избранные устройства". Первые три устройства в списке 
как раз обладают изображенными на макетах свойствами.

Должен признаться, что не тестировал работу приложения в мобильном сафари из-за отсутствия необходимых технических 
средств в моём распоряжении.
